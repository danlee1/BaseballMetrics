<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trackman Live Game Data Processor</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- Babel to transpile JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Helper Libraries for CSV parsing, Zipping, and PDF Generation -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <!-- PDF and Charting Libraries -->
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/jspdf-autotable@3.5.23/dist/jspdf.plugin.autotable.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect } = React;

        // Color Constant for #A6FF00 (Neon Green)
        const HIGHLIGHT_HEX = '#A6FF00';
        const HIGHLIGHT_RGB = [166, 255, 0];
        const PDF_FONT = 'helvetica';

        // --- SVG Icons ---
        const Icon = ({ className, children }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );

        const InboxIcon = ({ className }) => <Icon className={className}><path d="M22 12h-6l-2 3h-4l-2-3H2" /><path d="M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z" /></Icon>;
        const DownloadIcon = ({ className }) => <Icon className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></Icon>;
        const Loader2Icon = ({ className }) => <Icon className={className}><path d="M21 12a9 9 0 1 1-6.219-8.56" /></Icon>;
        const XCircleIcon = ({ className }) => <Icon className={className}><circle cx="12" cy="12" r="10" /><path d="m15 9-6 6" /><path d="m9 9 6 6" /></Icon>;
        const UsersIcon = ({ className }) => <Icon className={className}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></Icon>;
        const UserIcon = ({ className }) => <Icon className={className}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></Icon>;

        const App = () => {
            const [files, setFiles] = useState([]);
            const [pitcherFiles, setPitcherFiles] = useState(null);
            const [batterFiles, setBatterFiles] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [progress, setProgress] = useState(0);
            const [error, setError] = useState('');
            const [processingStatus, setProcessingStatus] = useState('');
            const [processingMode, setProcessingMode] = useState('both'); 
            const [useAutoClassification, setUseAutoClassification] = useState(false);
            
            const [reportOptions] = useState({
                showInsights: true,
                showVeloSpinChart: true,
                showMovementChart: true,
            });
            
            const logoUrl = 'https://raw.githubusercontent.com/danlee1/BaseballMetrics/refs/heads/main/images/Curve%20Sports-24.png'; 
            
            const libsLoaded = typeof window.Papa !== 'undefined' && 
                               typeof window.JSZip !== 'undefined' && 
                               typeof window.saveAs !== 'undefined' && 
                               typeof window.jspdf !== 'undefined' && 
                               typeof window.Chart !== 'undefined';

            const getImageBase64 = async (url) => {
                try {
                    const response = await fetch(url);
                    if (!response.ok) return null;
                    const blob = await response.blob();
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = () => resolve(null);
                        reader.readAsDataURL(blob);
                    });
                } catch (e) {
                    return null;
                }
            };

            const formatValue = (value) => {
                if (value === undefined || value === null || value === 'undefined' || value === '') return '';
                const num = Number(value);
                if (!isNaN(num) && String(value).trim() !== '') return num.toFixed(2);
                return value;
            };

            const classifyPitchHeuristic = (velo, ivb, hb, maxVelo) => {
                if (isNaN(velo) || isNaN(ivb) || isNaN(hb)) return null;
                const delta = velo - maxVelo;
                if (delta >= -3 && ivb > 12 && hb >= -5 && hb <= 5) return 'Fastball';
                if (delta >= -4 && ivb >= 4 && ivb <= 10 && hb > 10) return 'Sinker';
                if (delta <= -2 && delta >= -5 && ivb >= 8 && ivb <= 12 && hb <= -2 && hb >= -6) return 'Cutter';
                if (delta <= -5 && delta >= -10 && ivb >= 0 && ivb <= 6 && hb <= -5 && hb >= -15) return 'Slider';
                if (delta <= -11 && ivb < 0) return 'Curveball';
                if (delta <= -7 && delta >= -13 && ivb < 10 && hb > 8) return 'Changeup';
                return 'Fastball'; 
            };
            
            const generatePlayerInsights = async (playerName, pitchData, pitchType) => {
                if (pitchData.length === 0) return "Not enough data.";
                const avgVelo = pitchData.reduce((a, b) => a + b.x, 0) / pitchData.length;
                const maxVelo = Math.max(...pitchData.map(p => p.x));
                const avgSpin = pitchData.reduce((a, b) => a + b.y, 0) / pitchData.length;
                const avgHorz = pitchData.reduce((a, b) => a + b.horz, 0) / pitchData.length;
                const avgVert = pitchData.reduce((a, b) => a + b.vert, 0) / pitchData.length;

                const prompt = `You are a professional baseball data analyst specializing in high school and travel baseball development. 
                Provide 2 to 3 concise, fact-based bullet points interpreting ${playerName}'s ${pitchType} metrics. 
                Explain technical significance relative to high school travel competition (e.g., how Vertical Break creates 'ride' to beat HS hitters up in the zone). 
                Keep statements objective. Do not provide coaching advice.
                The entire response MUST be less than 200 words and fewer than 1250 characters total.
                Format as a list starting each point with "*" on a new line.

Metrics:
- Avg Velo: ${avgVelo.toFixed(1)} mph
- Max Velo: ${maxVelo.toFixed(1)} mph
- Avg Spin: ${avgSpin.toFixed(0)} rpm
- Avg IVB: ${avgVert.toFixed(1)}"
- Avg HB: ${avgHorz.toFixed(1)}"`;

                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (text) return text;
                    throw new Error("Empty AI response");
                } catch (err) {
                    return `* Average velocity recorded at ${avgVelo.toFixed(1)} mph.\n* Movement profile of ${avgVert.toFixed(1)}" IVB recorded.`;
                }
            };

            const handleFileChange = (event) => {
                const selectedFiles = Array.from(event.target.files || []);
                const csvFiles = selectedFiles.filter(f => f.name.toLowerCase().endsWith('.csv'));
                if (csvFiles.length < selectedFiles.length) {
                    setError('Only CSV files were processed.');
                } else {
                    setError('');
                }
                setFiles(csvFiles);
                setPitcherFiles(null);
                setBatterFiles(null);
                setProgress(0);
            };

            const handleProcess = async () => {
                if (files.length === 0) return;
                setIsLoading(true); setProgress(0); setError('');
                setProcessingStatus('Reading Data...');

                const pitchers = {};
                const batters = {};

                const processFile = (file) => {
                    return new Promise((resolve, reject) => {
                        window.Papa.parse(file, {
                            header: true, skipEmptyLines: true,
                            complete: (results) => {
                                results.data.forEach(row => {
                                    if (processingMode === 'both' || processingMode === 'pitchers') {
                                        const pName = row['Pitcher'];
                                        if (pName) {
                                            if (!pitchers[pName]) pitchers[pName] = { data: [], gameDate: row['Date'] || '', maxVelo: 0 };
                                            const velo = parseFloat(row['RelSpeed']);
                                            if (!isNaN(velo) && velo > pitchers[pName].maxVelo) pitchers[pName].maxVelo = velo;
                                            pitchers[pName].data.push({
                                                originalTagged: row['TaggedPitchType'],
                                                'Pitch Type': row['TaggedPitchType'],
                                                'Pitch Velocity': formatValue(row['RelSpeed']),
                                                'Spin Rate': formatValue(row['SpinRate']),
                                                'Vertical Break': formatValue(row['VertBreak']),
                                                'Induced Vertical Break': formatValue(row['InducedVertBreak']),
                                                'Horizontal Break': formatValue(row['HorzBreak']),
                                                'Release Height': formatValue(row['RelHeight']),
                                                'Release Side': formatValue(row['RelSide']),
                                                'Extension': formatValue(row['Extension']),
                                            });
                                        }
                                    }
                                    if (processingMode === 'both' || processingMode === 'batters') {
                                        const bName = row['Batter'];
                                        if (bName) {
                                            if (!batters[bName]) batters[bName] = { data: [], gameDate: row['Date'] || '' };
                                            batters[bName].data.push({
                                                'Exit Velocity': formatValue(row['ExitSpeed']),
                                                'Launch Angle': formatValue(row['Angle']),
                                                'Distance': formatValue(row['Distance']),
                                                'Hit Type': formatValue(row['TaggedHitType']),
                                                'Result': formatValue(row['PlayResult']),
                                            });
                                        }
                                    }
                                });
                                resolve();
                            },
                            error: (err) => reject(err)
                        });
                    });
                };

                try {
                    for (let i = 0; i < files.length; i++) {
                        await processFile(files[i]);
                        setProgress(Math.round(((i + 1) / files.length) * 50));
                    }
                    Object.keys(pitchers).forEach(name => {
                        const p = pitchers[name];
                        p.data.forEach(row => {
                            const original = (row.originalTagged || '').trim().toLowerCase();
                            const isUntagged = !original || original === 'unknown' || original === 'undefined' || original === '';
                            if (useAutoClassification && isUntagged) {
                                const inferred = classifyPitchHeuristic(parseFloat(row['Pitch Velocity']), parseFloat(row['Induced Vertical Break']), parseFloat(row['Horizontal Break']), p.maxVelo);
                                const finalInferred = inferred || 'Fastball';
                                row['Pitch Type'] = `${finalInferred} (inferred)`;
                                row.baseType = finalInferred;
                            } else {
                                row['Pitch Type'] = row.originalTagged || 'Unknown';
                                row.baseType = row['Pitch Type'];
                            }
                        });
                    });
                    setProgress(100);
                    setPitcherFiles(Object.keys(pitchers).length > 0 ? pitchers : null);
                    setBatterFiles(Object.keys(batters).length > 0 ? batters : null);
                } catch (e) { setError(`Parsing Error: ${e.message}`); }
                finally { setIsLoading(false); setProcessingStatus(''); }
            };

            const getChartAsImage = (config) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 400; canvas.height = 350;
                    const ctx = canvas.getContext('2d');
                    const whiteBackgroundPlugin = {
                        id: 'customCanvasBackgroundColor',
                        beforeDraw: (chart) => {
                            const {ctx} = chart; ctx.save();
                            ctx.globalCompositeOperation = 'destination-over';
                            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, chart.width, chart.height);
                            ctx.restore();
                        }
                    };
                    const chart = new window.Chart(ctx, {
                        ...config,
                        plugins: [whiteBackgroundPlugin, ...(config.plugins || [])],
                        options: { 
                            ...config.options, 
                            animation: false, 
                            responsive: false, 
                            devicePixelRatio: 2
                        }
                    });
                    chart.update('none');
                    const imgData = canvas.toDataURL('image/jpeg', 0.7);
                    chart.destroy(); resolve(imgData);
                });
            };

            const handleDownload = async (filesToZip, zipFileName) => {
                if (!filesToZip) return;
                setIsLoading(true); setProgress(0);
                setProcessingStatus('Preparing Reports...');
                const logoBase64 = await getImageBase64(logoUrl);

                try {
                    const zip = new window.JSZip();
                    const { jsPDF } = window.jspdf;
                    const players = Object.keys(filesToZip);

                    // Border Drawing Helper: 10px approx 3.5mm
                    const drawPageBorder = (doc) => {
                        const width = doc.internal.pageSize.getWidth();
                        const height = doc.internal.pageSize.getHeight();
                        const lineWidth = 3.5; 
                        doc.setLineWidth(lineWidth);
                        doc.setDrawColor(...HIGHLIGHT_RGB);
                        // Stroke the rectangle relative to center of line thickness
                        doc.rect(lineWidth / 2, lineWidth / 2, width - lineWidth, height - lineWidth, 'S');
                    };

                    for (let i = 0; i < players.length; i++) {
                        const key = players[i];
                        const playerData = filesToZip[key];
                        const tableData = playerData.data;
                        const nameParts = key.split(',').map(s => s.trim());
                        let lastNamePart = nameParts[0] || '';
                        let firstNamePart = nameParts[1] || '';
                        const gyMatch = lastNamePart.match(/\s(\d{4}|\d{2})$/);
                        let gy = gyMatch ? (gyMatch[1].length === 2 ? '20' + gyMatch[1] : gyMatch[1]) : '';
                        if (gyMatch) lastNamePart = lastNamePart.replace(gyMatch[0], '').trim();
                        const appMatch = firstNamePart.match(/(?:#\s?|\s)(\d+)$/);
                        let appId = appMatch ? appMatch[1] : '';
                        if (appMatch) firstNamePart = firstNamePart.replace(appMatch[0], '').trim();
                        const cleanPlayerName = `${firstNamePart} ${lastNamePart}`;
                        
                        setProcessingStatus(`Generating ${cleanPlayerName}...`);
                        setProgress(Math.round((i / players.length) * 100));

                        const doc = new jsPDF({ orientation: 'landscape' });
                        doc.setFont(PDF_FONT, 'normal');
                        drawPageBorder(doc); // Page 1 Border

                        if (logoBase64) doc.addImage(logoBase64, 'PNG', 15, 10, 50, 0);

                        let currentTopY = 48; 
                        if (zipFileName === 'pitchers.zip') {
                            const intro = "This dataset contains your live game pitching data recorded by TrackMan. It includes detailed information on each pitch tracked during game action, such as velocity, movement, spin, and location metrics. The goal of sharing this data is to provide you with clear insights into your performance, highlight strengths, and identify areas for continued development. We encourage you to review this data with your pitching coach to maximize its value as a tool for growth.";
                            let boxH = 13; if (gy) boxH += 6; if (appId) boxH += 6; if (playerData.gameDate) boxH += 6;
                            const introLines = doc.splitTextToSize(intro, 277);
                            const finalBoxH = boxH + (introLines.length * 4.5) + 15;
                            
                            doc.setFillColor(...HIGHLIGHT_RGB); 
                            doc.rect(10, 35, 277, finalBoxH, 'F');
                            doc.setTextColor(0, 0, 0); 
                            doc.setFont(PDF_FONT, 'bold').setFontSize(22);
                            doc.text(cleanPlayerName, 15, currentTopY);
                            
                            let headerY = currentTopY + 8;
                            doc.setFont(PDF_FONT, 'normal').setFontSize(12);
                            if (gy) { doc.text(`Graduation Year: ${gy}`, 15, headerY); headerY += 6; }
                            if (appId) { doc.text(`Appointment ID: ${appId}`, 15, headerY); headerY += 6; }
                            if (playerData.gameDate) { doc.text(`Game Date: ${playerData.gameDate}`, 15, headerY); }
                            doc.setFontSize(11).text(introLines, 15, headerY + 10);
                            currentTopY = 35 + finalBoxH + 10;

                            const arsenal = {};
                            tableData.forEach(p => {
                                let type = (p.baseType || 'Unknown').trim();
                                if (!type || type.toLowerCase() === 'unknown') return;
                                if (!arsenal[type]) arsenal[type] = [];
                                arsenal[type].push({ x: parseFloat(p['Pitch Velocity']), y: parseFloat(p['Spin Rate']), horz: parseFloat(p['Horizontal Break']), vert: parseFloat(p['Induced Vertical Break']) });
                            });

                            const renderPitchPage = async (title, data, isSubPage = false) => {
                                const chartH = 80;
                                let totalTextHeight = 0; let bulletData = [];
                                if (reportOptions.showInsights) {
                                    const text = await generatePlayerInsights(cleanPlayerName, data, title);
                                    text.split('\n').filter(l => l.trim().startsWith('*')).forEach(p => {
                                        const lines = doc.splitTextToSize(p.trim().substring(1).trim(), 80);
                                        const h = (lines.length * 4) + 2;
                                        bulletData.push({ lines, h }); totalTextHeight += h;
                                    });
                                }
                                const labelHeight = 8; const textBlockHeight = reportOptions.showInsights ? (labelHeight + totalTextHeight) : labelHeight;
                                const maxHeight = Math.max(textBlockHeight, chartH);
                                if (isSubPage) currentTopY = (doc.internal.pageSize.getHeight() - maxHeight) / 2;
                                let textStartY = currentTopY + (maxHeight - textBlockHeight) / 2;
                                let chartY = currentTopY + (maxHeight - chartH) / 2;

                                if (reportOptions.showInsights) {
                                    doc.setFont(PDF_FONT, 'bold').setFontSize(12).text(`${title} Characterization`, 15, textStartY + 5);
                                    doc.setFont(PDF_FONT, 'normal').setFontSize(10);
                                    let y = textStartY + labelHeight + 2;
                                    bulletData.forEach(item => { doc.text('•', 15, y); doc.text(item.lines, 20, y); y += item.h; });
                                } else {
                                    doc.setFont(PDF_FONT, 'bold').setFontSize(14).text(`${title} Analysis`, 15, textStartY + 5);
                                }
                                const charts = [reportOptions.showVeloSpinChart && 'velo', reportOptions.showMovementChart && 'move'].filter(Boolean);
                                const chartW = (297 - 100 - 15 - 5) / (charts.length || 1);
                                let chartStartX = 100;
                                
                                if (reportOptions.showVeloSpinChart) {
                                    const img = await getChartAsImage({
                                        type: 'scatter', 
                                        data: { datasets: [{ data: data.map(pt => ({x: pt.x, y: pt.y})), backgroundColor: HIGHLIGHT_HEX }] },
                                        options: { plugins: { legend: { display: false }, title: { display: true, text: `${title} Velo vs Spin` } }, scales: { x: { title: { display: true, text: 'Velo' } }, y: { title: { display: true, text: 'Spin' } } } }
                                    });
                                    doc.addImage(img, 'JPEG', chartStartX, chartY, chartW, chartH);
                                    chartStartX += chartW + 5;
                                }
                                if (reportOptions.showMovementChart) {
                                    const img = await getChartAsImage({
                                        type: 'scatter', 
                                        data: { datasets: [{ data: data.map(pt => ({x: pt.horz, y: pt.vert})), backgroundColor: HIGHLIGHT_HEX }] },
                                        options: { plugins: { legend: { display: false }, title: { display: true, text: `${title} Movement Profile` } }, scales: { x: { title: { display: true, text: 'HB' } }, y: { title: { display: true, text: 'IVB' } } } }
                                    });
                                    doc.addImage(img, 'JPEG', chartStartX, chartY, chartW, chartH);
                                }
                                return currentTopY + maxHeight + 15;
                            };

                            const fbKeys = Object.keys(arsenal).filter(k => k.toLowerCase().includes('fastball'));
                            let allFbData = []; fbKeys.forEach(k => { allFbData = allFbData.concat(arsenal[k]); });
                            await renderPitchPage('Fastball', allFbData.filter(pt => !isNaN(pt.x)), false);

                            const others = Object.keys(arsenal).filter(k => !k.toLowerCase().includes('fastball'));
                            for (const type of others) {
                                const pts = arsenal[type].filter(pt => !isNaN(pt.x));
                                if (pts.length >= 3) { 
                                    doc.addPage(); 
                                    drawPageBorder(doc); // Subpage Border
                                    await renderPitchPage(type, pts, true); 
                                }
                            }

                            doc.addPage();
                            drawPageBorder(doc); // Table Page Border
                            const head = [Object.keys(tableData[0]).filter(k => k !== 'originalTagged' && k !== 'baseType')];
                            const body = tableData.map(row => Object.keys(row).filter(k => k !== 'originalTagged' && k !== 'baseType').map(k => row[k]));
                            
                            doc.autoTable({ 
                                head, body, 
                                styles: { fontSize: 8, font: PDF_FONT },
                                headStyles: { fillColor: HIGHLIGHT_RGB, textColor: [0, 0, 0], fontStyle: 'bold' },
                                didDrawPage: (data) => {
                                    // Ensure border on multi-page tables
                                    drawPageBorder(doc);
                                }
                            });
                        } else {
                            const head = [Object.keys(tableData[0])];
                            const body = tableData.map(row => Object.values(row));
                            doc.autoTable({ 
                                head, body, startY: currentTopY, 
                                styles: { fontSize: 8, font: PDF_FONT },
                                headStyles: { fillColor: HIGHLIGHT_RGB, textColor: [0, 0, 0], fontStyle: 'bold' },
                                didDrawPage: (data) => {
                                    drawPageBorder(doc);
                                }
                            });
                        }
                        zip.file(`${cleanPlayerName.replace(/\s/g, '_')}.pdf`, doc.output('blob'));
                    }
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    window.saveAs(zipBlob, zipFileName);
                } catch (err) { setError(`Error: ${err.message}`); }
                finally { setIsLoading(false); setProcessingStatus(''); setProgress(0); }
            };

            return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="w-full max-w-3xl bg-white rounded-xl shadow-lg p-6 md:p-8 space-y-6">
                        <div className="text-center">
                            <img src={logoUrl} alt="Logo" className="mx-auto h-16 w-auto mb-4" />
                            <h1 className="text-3xl font-bold text-slate-800 uppercase tracking-tight">Trackman Live Game Data Processor</h1>
                        </div>
                        <div className="space-y-4">
                            <h2 className="text-lg font-semibold text-slate-700">Step 1: Upload CSV Files</h2>
                            <label htmlFor="csv-upload" className="w-full block p-8 border-2 border-dashed rounded-lg text-center cursor-pointer border-slate-300 hover:border-lime-500 transition-colors">
                                <InboxIcon className="w-12 h-12 mx-auto mb-4 text-lime-600" />
                                <p className="text-slate-500 font-medium">Select Trackman CSV Files</p>
                            </label>
                            <input id="csv-upload" type="file" accept=".csv" multiple className="hidden" onChange={handleFileChange} />
                            {files.length > 0 && (
                                <div className="bg-slate-50 p-3 rounded-lg border border-slate-200 max-h-40 overflow-y-auto">
                                    <p className="text-sm font-bold text-slate-600 mb-1">{files.length} Files Selected</p>
                                    {files.map((f, i) => <div key={i} className="text-xs text-slate-500 truncate">• {f.name}</div>)}
                                </div>
                            )}
                        </div>
                        {files.length > 0 && !pitcherFiles && !batterFiles && (
                            <div className="space-y-4 pt-4 border-t border-slate-100">
                                <div className="flex flex-col space-y-4">
                                    <div className="flex items-center space-x-2 bg-slate-100 p-1 rounded-lg">
                                        {['both', 'pitchers', 'batters'].map(m => (
                                            <button key={m} onClick={() => setProcessingMode(m)} className={`flex-1 capitalize py-2 px-4 rounded-md text-sm font-bold transition-all ${processingMode === m ? 'bg-lime-500 text-black shadow' : 'text-slate-500 hover:bg-slate-200'}`}>{m}</button>
                                        ))}
                                    </div>
                                    <label className="flex items-center space-x-3 cursor-pointer p-2 bg-slate-50 rounded-lg border border-slate-200">
                                        <input type="checkbox" className="w-5 h-5 text-lime-600 rounded cursor-pointer" checked={useAutoClassification} onChange={(e) => setUseAutoClassification(e.target.checked)} />
                                        <div className="flex flex-col">
                                            <span className="text-sm font-bold text-slate-700">Auto Pitch Type Classification</span>
                                            <span className="text-xs text-slate-500">Automatically group untagged pitches using heuristics (max 200 words per pitch)</span>
                                        </div>
                                    </label>
                                </div>
                                <button onClick={handleProcess} disabled={isLoading || !libsLoaded} className="w-full flex items-center justify-center p-4 bg-lime-500 text-black font-bold rounded-lg hover:bg-lime-600 transition-all disabled:bg-slate-300 uppercase">
                                    {isLoading ? <><Loader2Icon className="w-6 h-6 animate-spin mr-2" /> {processingStatus || 'Processing...'}</> : 'Process All Selected Files'}
                                </button>
                                {isLoading && <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden"><div className="bg-lime-500 h-full transition-all duration-300" style={{width: `${progress}%`}}></div></div>}
                            </div>
                        )}
                        {error && <div className="bg-red-50 text-red-600 p-4 rounded-lg flex items-center text-sm border border-red-100"><XCircleIcon className="w-5 h-5 mr-3 flex-shrink-0"/>{error}</div>}
                        {(pitcherFiles || batterFiles) && (
                             <div className="space-y-6 pt-4 border-t border-slate-200">
                                <h2 className="text-lg font-semibold text-slate-700">Step 3: Download Reports</h2>
                                {isLoading && (
                                    <div className="space-y-2">
                                        <p className="text-xs text-center font-bold text-lime-600 truncate">{processingStatus} ({progress}%)</p>
                                        <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden"><div className="bg-lime-500 h-full transition-all duration-300" style={{width: `${progress}%`}}></div></div>
                                    </div>
                                )}
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {pitcherFiles && (
                                        <div className="p-4 rounded-lg border border-slate-200 bg-white shadow-sm hover:shadow-md transition-shadow">
                                            <div className="flex items-center mb-3"><UserIcon className="w-5 h-5 mr-2 text-lime-600"/><span className="font-bold">{Object.keys(pitcherFiles).length} Pitcher Profiles Found</span></div>
                                            <button onClick={() => handleDownload(pitcherFiles, 'pitchers.zip')} disabled={isLoading} className="w-full flex items-center justify-center p-3 bg-lime-500 text-black rounded-lg font-bold hover:bg-lime-600 disabled:bg-slate-300 transition-colors uppercase">Download Pitchers.zip</button>
                                        </div>
                                    )}
                                    {batterFiles && (
                                        <div className="p-4 rounded-lg border border-slate-200 bg-white shadow-sm hover:shadow-md transition-shadow">
                                            <div className="flex items-center mb-3"><UsersIcon className="w-5 h-5 mr-2 text-sky-500"/><span className="font-bold">{Object.keys(batterFiles).length} Batter Profiles Found</span></div>
                                            <button onClick={() => handleDownload(batterFiles, 'batters.zip')} disabled={isLoading} className="w-full flex items-center justify-center p-3 bg-lime-500 text-black rounded-lg font-bold hover:bg-lime-600 disabled:bg-slate-300 transition-colors uppercase">Download Batters.zip</button>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>