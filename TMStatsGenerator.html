<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Player Report Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-label {
            transition: all 0.2s ease-in-out;
        }
        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .spinner {
            border-top-color: transparent;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <div class="flex justify-center items-center">
                <img src="https://app.curvetestcenters.com/_next/image?url=%2Flogos%2FPNG%2Fcurve-2.0-logo_full-hrz-logo-only.png&w=1920&q=75" alt="Curve Logo" class="h-10 sm:h-12 mr-4">
                <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Player Report Generator</h1>
            </div>
            <p class="mt-2 text-md text-gray-600">A two-part tool to process and merge player data.</p>
        </header>

        <main class="space-y-8">
            <!-- Part 1: Generate Initial Report -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">Part 1: Generate Player Metrics Report</h2>
                <div class="mt-4">
                    <label for="csvFiles" class="file-label cursor-pointer w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg inline-flex items-center justify-center">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                        <span>Select Hitting/Pitching Files</span>
                    </label>
                    <input type="file" id="csvFiles" class="hidden" multiple accept=".csv">
                    <p id="fileList" class="mt-4 text-sm text-gray-500">No files selected.</p>
                </div>
                <div class="mt-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="part1Underscores" class="form-checkbox h-5 w-5 text-blue-600" checked>
                        <span class="ml-2 text-gray-700">Replace spaces with underscores in headers</span>
                    </label>
                </div>
                 <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="processBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-sm hover:shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed inline-flex items-center justify-center">
                        <span id="processBtnText">Generate & Download Report</span>
                        <div id="spinner" class="spinner border-4 border-white rounded-full ml-3 hidden"></div>
                    </button>
                </div>
            </div>
            
            <!-- Part 2: Join Files -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4 border-b pb-2">Part 2: Join and Create Final Report</h2>
                <p class="text-sm text-gray-600 mb-4">Upload your corrected report from Part 1 and the second CSV file to join them.</p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                    <div>
                        <label for="metricsFile" class="file-label cursor-pointer w-full bg-gray-700 text-white font-bold py-3 px-4 rounded-lg inline-flex items-center justify-center">
                            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                            <span>Upload Ball Data</span>
                        </label>
                        <input type="file" id="metricsFile" class="hidden" accept=".csv">
                        <p id="metricsFileList" class="mt-4 text-sm text-gray-500">No file selected.</p>
                    </div>
                    <div>
                        <label for="joinFile" class="file-label cursor-pointer w-full bg-gray-700 text-white font-bold py-3 px-4 rounded-lg inline-flex items-center justify-center">
                            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4M4 7v10"></path></svg>
                            <span>Upload Athletic Data</span>
                        </label>
                        <input type="file" id="joinFile" class="hidden" accept=".csv">
                        <p id="joinFileList" class="mt-4 text-sm text-gray-500">No file selected.</p>
                    </div>
                </div>
                <div class="mt-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="part2Underscores" class="form-checkbox h-5 w-5 text-purple-600" checked>
                        <span class="ml-2 text-gray-700">Replace spaces with underscores in athletic data headers</span>
                    </label>
                </div>

                 <div class="flex flex-col sm:flex-row gap-4 mt-6">
                    <button id="joinBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-sm hover:shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">Join and Download Final Report</button>
                </div>
            </div>

            <!-- Status Area -->
            <div id="status" class="mt-4 p-4 bg-gray-50 rounded-lg text-sm min-h-[50px]"></div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const csvFilesInput = document.getElementById('csvFiles');
            const fileList = document.getElementById('fileList');
            const processBtn = document.getElementById('processBtn');
            const processBtnText = document.getElementById('processBtnText');
            const spinner = document.getElementById('spinner');
            const statusDiv = document.getElementById('status');
            const part1UnderscoresCheckbox = document.getElementById('part1Underscores');
            
            const metricsFileInput = document.getElementById('metricsFile');
            const metricsFileList = document.getElementById('metricsFileList');
            const joinFileInput = document.getElementById('joinFile');
            const joinFileList = document.getElementById('joinFileList');
            const joinBtn = document.getElementById('joinBtn');
            const part2UnderscoresCheckbox = document.getElementById('part2Underscores');

            // --- Global Constants ---
            const PITCH_TYPES = ['Fastball', 'Sinker', 'Slider', 'CurveBall', 'ChangeUp', 'Splitter'];
            const PITCHING_METRICS = ['Peak_Velocity', 'Average_Velocity', 'Average_IVB', 'Average_HB', 'Strike_%', 'Count'];
            
            const basePart1Headers = [
                'Last_Name', 'First_Name', 'Graduation_Year', 'Appointment_ID', 'Date', 'Practice_Type', 
                'Peak_Exit_Velocity', 'EV_50', 'Launch_Angle_(0-30%)', 'Hard_Hit_%', 'Barrel_%'
            ];
            PITCH_TYPES.forEach(pitchType => {
                PITCHING_METRICS.forEach(metric => {
                    basePart1Headers.push(`${pitchType}_${metric}`);
                });
            });

            // --- Event Listeners ---
            csvFilesInput.addEventListener('change', () => {
                fileList.textContent = csvFilesInput.files.length > 0 ? `${csvFilesInput.files.length} file(s) selected.` : 'No files selected.';
            });
            metricsFileInput.addEventListener('change', () => {
                metricsFileList.textContent = metricsFileInput.files.length > 0 ? metricsFileInput.files[0].name : 'No file selected.';
            });
            joinFileInput.addEventListener('change', () => {
                joinFileList.textContent = joinFileInput.files.length > 0 ? joinFileInput.files[0].name : 'No file selected.';
            });
            
            processBtn.addEventListener('click', handlePart1Generation);
            joinBtn.addEventListener('click', handlePart2JoinAndDownload);

            // --- Core Functions ---
            async function handlePart1Generation() {
                const files = csvFilesInput.files;
                if (files.length === 0) {
                    log('Please select at least one CSV file for Part 1.', 'error');
                    return;
                }

                processBtn.disabled = true;
                processBtnText.textContent = 'Processing...';
                spinner.classList.remove('hidden');
                log('Starting Part 1 report generation...', 'info');

                try {
                    const allFilesData = await Promise.all(Array.from(files).map(readFile));
                    let combinedData = [];
                    allFilesData.forEach(file => combinedData = combinedData.concat(file.data));
                    
                    const { grouped, failed } = groupDataByPlayerAndPractice(combinedData);
                    
                    const reportData = [];
                    for (const groupKey in grouped) {
                        const playerRows = grouped[groupKey];
                        const rawPlayerName = playerRows[0].Batter || playerRows[0].Pitcher;
                        const practiceType = playerRows[0]?.PracticeType || 'unknown';
                        const date = playerRows[0]?.Date || '';

                        const { lastName, firstName, graduationYear, appointmentId } = parsePlayerName(rawPlayerName);

                        const baseRow = {};
                        basePart1Headers.forEach(h => baseRow[h] = ''); // Internal keys always use underscores
                        baseRow.Last_Name = lastName;
                        baseRow.First_Name = firstName;
                        baseRow.Graduation_Year = graduationYear;
                        baseRow.Appointment_ID = appointmentId;
                        baseRow.Date = date;
                        baseRow.Practice_Type = practiceType;

                        if (practiceType.toLowerCase() === 'hitting') {
                            const metrics = calculateHittingMetrics(playerRows);
                            reportData.push({ ...baseRow, ...metrics });
                        } else {
                            const metrics = calculatePitchingMetrics(playerRows);
                            reportData.push({ ...baseRow, ...metrics });
                        }
                    }
                    
                    const useUnderscores = part1UnderscoresCheckbox.checked;
                    const displayHeaders = useUnderscores ? basePart1Headers : basePart1Headers.map(h => h.replace(/_/g, ' '));
                    
                    downloadCSV(reportData, displayHeaders, 'part_1_metrics_report.csv');
                    let successMessage = 'Part 1 report downloaded successfully. You can now manually edit it before proceeding to Part 2.';

                    if (failed.length > 0) {
                        const errorHeaders = Object.keys(failed[0]);
                        downloadCSV(failed, errorHeaders, 'part_1_errors.csv');
                        successMessage += ` An additional file with ${failed.length} unprocessed rows has also been downloaded.`;
                    }
                    log(successMessage, 'success');

                } catch (error) {
                    log(`An error occurred in Part 1: ${error.message}`, 'error');
                    console.error(error);
                } finally {
                    processBtn.disabled = false;
                    processBtnText.textContent = 'Generate & Download Report';
                    spinner.classList.add('hidden');
                }
            }

            async function handlePart2JoinAndDownload() {
                const metricsFile = metricsFileInput.files[0];
                const joinFile = joinFileInput.files[0];

                if (!metricsFile || !joinFile) {
                    log('Please select both the Ball Data and the Athletic Data file for Part 2.', 'error');
                    return;
                }

                joinBtn.disabled = true;
                joinBtn.textContent = 'Joining...';
                log('Reading files for joining...', 'info');

                try {
                    const [metricsFileData, joinFileData] = await Promise.all([readFile(metricsFile), readFile(joinFile)]);
                    log('Files read. Merging data...', 'info');
                    
                    const failedRows = [];
                    const useUnderscores = part2UnderscoresCheckbox.checked;

                    const dynamicJoinHeaders = joinFileData.headers.filter(h => 
                        h.toLowerCase() !== 'last name' && h.toLowerCase() !== 'first name'
                    );
                    const finalDynamicHeaders = useUnderscores ? dynamicJoinHeaders.map(h => h.replace(/ /g, '_').replace(/#/g, '')) : dynamicJoinHeaders;

                    const joinMap = new Map();
                    joinFileData.data.forEach(row => {
                        const lastName = row['Last Name']?.trim().toLowerCase();
                        const firstName = row['First Name']?.trim().toLowerCase();
                        if (lastName && firstName) {
                            joinMap.set(`${lastName}|${firstName}`, row);
                        } else {
                            row.Error_Reason = 'Missing Last_Name or First_Name in Athletic Data file.';
                            failedRows.push(row);
                        }
                    });

                    const finalReport = metricsFileData.data.map(metricsRow => {
                        const lastNameKey = Object.keys(metricsRow).find(k => k.toLowerCase().replace(/_/g, ' ') === 'last name') || 'Last_Name';
                        const firstNameKey = Object.keys(metricsRow).find(k => k.toLowerCase().replace(/_/g, ' ') === 'first name') || 'First_Name';
                        const lastName = metricsRow[lastNameKey]?.trim().toLowerCase();
                        const firstName = metricsRow[firstNameKey]?.trim().toLowerCase();
                        
                        if (!lastName || !firstName) {
                            metricsRow.Error_Reason = 'Missing Last_Name or First_Name in Ball Data file.';
                            failedRows.push(metricsRow);
                            return null;
                        }

                        const key = `${lastName}|${firstName}`;
                        const mergedRow = { ...metricsRow };

                        if (joinMap.has(key)) {
                            const joinRow = joinMap.get(key);
                            dynamicJoinHeaders.forEach((headerWithSpace, index) => {
                                const finalHeader = finalDynamicHeaders[index];
                                mergedRow[finalHeader] = joinRow[headerWithSpace] || '';
                            });
                        }
                        return mergedRow;
                    }).filter(Boolean);
                    
                    const finalHeaders = [...metricsFileData.headers, ...finalDynamicHeaders];
                    downloadCSV(finalReport, finalHeaders, 'final_joined_report.csv');
                    
                    let successMessage = 'Final report downloaded successfully!';
                    if (failedRows.length > 0) {
                        const errorHeaders = [...new Set(failedRows.flatMap(Object.keys))];
                        downloadCSV(failedRows, errorHeaders, 'part_2_join_errors.csv');
                        successMessage += ` An additional file with ${failedRows.length} rows that failed to join has also been downloaded.`;
                    }
                    log(successMessage, 'success');

                } catch (error) {
                    log(`An error occurred during the join process: ${error.message}`, 'error');
                    console.error(error);
                } finally {
                    joinBtn.disabled = false;
                    joinBtn.textContent = 'Join and Download Final Report';
                }
            }

            function readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const text = event.target.result;
                            const parsed = parseCSV(text);
                            resolve(parsed);
                        } catch (e) {
                            reject(new Error(`Failed to parse ${file.name}: ${e.message}`));
                        }
                    };
                    reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                    reader.readAsText(file);
                });
            }
            
            function parseCSV(text) {
                const lines = text.trim().split(/\r?\n/);
                if (lines.length < 1) return { data: [], headers: [] };

                const parseLine = (line) => {
                    const values = [];
                    let currentVal = '';
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            if (inQuotes && line[i + 1] === '"') {
                                currentVal += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            values.push(currentVal.trim());
                            currentVal = '';
                        } else {
                            currentVal += char;
                        }
                    }
                    values.push(currentVal.trim());
                    return values;
                };

                const headers = parseLine(lines[0]).map(h => h.trim().replace(/"/g, ''));
                
                const data = lines.slice(1).map(line => {
                    if (!line) return null;
                    const values = parseLine(line);
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].replace(/"/g, '') : '';
                    });
                    return row;
                }).filter(Boolean);

                return { data, headers };
            }
            
            function parsePlayerName(fullName) {
                if (!fullName) return { lastName: '', firstName: '', graduationYear: '', appointmentId: '' };
                
                const nameSplit = fullName.split(',');
                let preCommaPart = nameSplit[0] ? nameSplit[0].trim() : '';
                let postCommaPart = nameSplit[1] ? nameSplit[1].trim() : '';

                let lastName = '';
                let graduationYear = '';
                let firstName = '';
                let appointmentId = '';

                const yearMatch = preCommaPart.match(/(.*\D)?\s*(\d{4})$/);
                if (yearMatch) {
                    lastName = yearMatch[1] ? yearMatch[1].trim() : '';
                    graduationYear = yearMatch[2];
                } else {
                    lastName = preCommaPart;
                }

                if (!postCommaPart) {
                     return { lastName, firstName, graduationYear, appointmentId };
                }

                if (postCommaPart.includes('#')) {
                    const idSplit = postCommaPart.split('#');
                    firstName = idSplit[0].trim();
                    appointmentId = idSplit[1] || '';
                } else {
                    const match = postCommaPart.match(/^(.*\D)?(\d+.*)$/);
                    if (match) {
                        firstName = match[1] ? match[1].trim() : '';
                        appointmentId = match[2] ? match[2].trim() : '';
                    } else {
                        firstName = postCommaPart;
                    }
                }
                return { lastName, firstName, graduationYear, appointmentId };
            }

             function groupData(data, key) {
                return data.reduce((acc, row) => {
                    const groupKey = row[key];
                    if (groupKey) {
                        if (!acc[groupKey]) acc[groupKey] = [];
                        acc[groupKey].push(row);
                    }
                    return acc;
                }, {});
            }

            function groupDataByPlayerAndPractice(data) {
                const grouped = {};
                const failed = [];
                data.forEach(row => {
                    const playerName = row.Batter || row.Pitcher;
                    const practiceType = row.PracticeType;
                    if (playerName && practiceType) {
                        const groupKey = `${playerName}|${practiceType}`;
                        if (!grouped[groupKey]) grouped[groupKey] = [];
                        grouped[groupKey].push(row);
                    } else {
                        row.Error_Reason = 'Missing Batter/Pitcher name or Practice_Type.';
                        failed.push(row);
                    }
                });
                return { grouped, failed };
            }

            // --- METRIC CALCULATION FUNCTIONS ---
            
            function calculateHittingMetrics(rows) {
                const exitSpeeds = rows.map(r => parseFloat(r.ExitSpeed)).filter(v => !isNaN(v));
                const angles = rows.map(r => parseFloat(r.Angle)).filter(v => !isNaN(v));
                const validHitRows = rows.filter(r => !isNaN(parseFloat(r.ExitSpeed)) && !isNaN(parseFloat(r.Angle)));
                const peakEV = exitSpeeds.length > 0 ? Math.max(...exitSpeeds) : 0;
                const sortedSpeeds = [...exitSpeeds].sort((a, b) => b - a);
                const top50PercentCount = Math.ceil(sortedSpeeds.length / 2);
                const top50Speeds = sortedSpeeds.slice(0, top50PercentCount);
                let ev50 = 0;
                if (top50Speeds.length > 0) ev50 = top50Speeds.reduce((a, b) => a + b, 0) / top50Speeds.length;
                const idealAngleHits = angles.filter(a => a >= 0 && a <= 30).length;
                const launchAnglePercent = angles.length > 0 ? (idealAngleHits / angles.length) * 100 : 0;
                const hardHits = exitSpeeds.filter(s => s > 85).length;
                const hardHitPercent = exitSpeeds.length > 0 ? (hardHits / exitSpeeds.length) * 100 : 0;
                const barrelHits = validHitRows.filter(r => parseFloat(r.ExitSpeed) > 85 && parseFloat(r.Angle) >= 0 && parseFloat(r.Angle) <= 30).length;
                const barrelPercent = validHitRows.length > 0 ? (barrelHits / validHitRows.length) * 100 : 0;
                return {
                    'Peak_Exit_Velocity': peakEV.toFixed(1),
                    'EV_50': ev50.toFixed(1),
                    'Launch_Angle_(0-30%)': `${launchAnglePercent.toFixed(1)}%`,
                    'Hard_Hit_%': `${hardHitPercent.toFixed(1)}%`,
                    'Barrel_%': `${barrelPercent.toFixed(1)}%`
                };
            }

            function calculatePitchingMetrics(rows) {
                const groupedByPitchType = groupData(rows, 'TaggedPitchType');
                const allMetrics = {};
                PITCH_TYPES.forEach(pitchType => {
                    const pitchTypeRows = groupedByPitchType[pitchType] || [];
                    if (pitchTypeRows.length === 0) {
                        PITCHING_METRICS.forEach(metric => allMetrics[`${pitchType}_${metric}`] = '');
                        return;
                    }
                    const relSpeeds = pitchTypeRows.map(r => parseFloat(r.RelSpeed)).filter(v => !isNaN(v));
                    const ivbs = pitchTypeRows.map(r => parseFloat(r.InducedVertBreak)).filter(v => !isNaN(v));
                    const hbs = pitchTypeRows.map(r => parseFloat(r.HorzBreak)).filter(v => !isNaN(v));
                    const validStrikeZoneRows = pitchTypeRows.filter(r => !isNaN(parseFloat(r.PlateLocSide)) && !isNaN(parseFloat(r.PlateLocHeight)));
                    allMetrics[`${pitchType}_Count`] = pitchTypeRows.length;
                    const peakVelo = relSpeeds.length > 0 ? Math.max(...relSpeeds) : 0;
                    allMetrics[`${pitchType}_Peak_Velocity`] = peakVelo.toFixed(1);
                    let avgVelo = 0;
                    if(relSpeeds.length > 0) avgVelo = relSpeeds.reduce((a, b) => a + b, 0) / relSpeeds.length;
                    allMetrics[`${pitchType}_Average_Velocity`] = avgVelo.toFixed(1);
                    let avgIVB = 0;
                    if(ivbs.length > 0) avgIVB = ivbs.reduce((a, b) => a + b, 0) / ivbs.length;
                    allMetrics[`${pitchType}_Average_IVB`] = avgIVB.toFixed(1);
                    let avgHB = 0;
                    if(hbs.length > 0) avgHB = hbs.reduce((a, b) => a + b, 0) / hbs.length;
                    allMetrics[`${pitchType}_Average_HB`] = avgHB.toFixed(1);
                    const strikes = validStrikeZoneRows.filter(r => {
                        const side = parseFloat(r.PlateLocSide);
                        const height = parseFloat(r.PlateLocHeight);
                        return side >= -0.708 && side <= 0.708 && height >= 1.5 && height <= 3.5;
                    }).length;
                    const strikePercent = validStrikeZoneRows.length > 0 ? (strikes / validStrikeZoneRows.length) * 100 : 0;
                    allMetrics[`${pitchType}_Strike_%`] = `${strikePercent.toFixed(1)}%`;
                });
                return allMetrics;
            }

            function downloadCSV(data, headers, filename) {
                if (!data || data.length === 0) {
                    if (filename.includes('error')) return;
                    log('No data available to download.', 'error');
                    return;
                }
                const csvRows = [headers.join(',')];
                data.forEach(row => {
                    const values = headers.map(header => {
                        const key = header.replace(/ /g, '_');
                        const val = row[key] !== undefined ? row[key] : '';
                        const escaped = ('' + val).replace(/"/g, '""');
                        return `"${escaped}"`;
                    });
                    csvRows.push(values.join(','));
                });
                const csvString = csvRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            function log(message, type = 'info') {
                const colorClasses = {
                    info: 'text-gray-700 bg-gray-100',
                    success: 'text-green-700 bg-green-100',
                    error: 'text-red-700 bg-red-100',
                };
                statusDiv.innerHTML = `<p class="${colorClasses[type]} p-3 rounded-md">${message}</p>`;
            }
        });
    </script>
</body>
</html>
